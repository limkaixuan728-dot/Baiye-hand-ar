<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç™½ä¹ŸÂ·ç²’å­å®‡å®™ç»ˆæç‰ˆ</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #panel { position: absolute; top: 15px; left: 15px; z-index: 10; color: #0ff; font-family: "Microsoft YaHei", sans-serif; background: rgba(0,20,40,0.8); padding: 12px; border: 1px solid #0ff; border-radius: 8px; pointer-events: none; }
        video { display: none; }
    </style>
</head>
<body>
    <div id="panel">åˆå§‹åŒ– AI å¼•æ“...</div>
    <video id="input_video" playsinline autoplay muted></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const panel = document.getElementById('panel');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- æ ¸å¿ƒé…ç½® ---
        const P_COUNT = 18000; // ç²’å­æ•°é‡
        let currentState = 'SPHERE';
        let handData = { x:0, y:0, z:1, vX:0, vY:0, active: false };
        let lastHandPos = { x:0, y:0 };

        // --- ç²’å­ç³»ç»Ÿæ„å»º ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(P_COUNT * 3);
        const targets = new Float32Array(P_COUNT * 3); // ç›®æ ‡å½¢çŠ¶
        const vels = new Float32Array(P_COUNT * 3); // ç²’å­å½“å‰é€Ÿåº¦
        
        for(let i=0; i<P_COUNT*3; i++) {
            positions[i] = (Math.random()-0.5)*50;
            vels[i] = 0;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.05, transparent: true, blending: THREE.AdditiveBlending });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);
        camera.position.z = 15;

        // --- æ–‡å­—åæ ‡é‡‡é›† (Canvas) ---
        const textCoords = [];
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 200; canvas.height = 100;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 24px Arial';
        ctx.fillText('æˆ‘æ˜¯ç™½ä¹Ÿ', 10, 50);
        const imgData = ctx.getImageData(0,0,200,100).data;
        for(let y=0; y<100; y+=1) {
            for(let x=0; x<200; x+=1) {
                if(imgData[(y*200+x)*4] > 128) textCoords.push({x:(x-100)/10, y:(50-y)/10});
            }
        }

        // --- å½¢çŠ¶è®¡ç®—é€»è¾‘ ---
        function setTargetShape(shape) {
            if(currentState === shape) return;
            currentState = shape;
            // åˆ‡æ¢ç¬é—´è§¦å‘â€œçˆ†ç‚¸â€ç‰¹æ•ˆé€Ÿåº¦
            for(let i=0; i<P_COUNT*3; i++) vels[i] += (Math.random()-0.5) * 2; 

            for(let i=0; i<P_COUNT; i++) {
                let idx = i * 3;
                if(shape === 'SPHERE') {
                    const phi = Math.acos(-1 + (2 * i) / P_COUNT);
                    const theta = Math.sqrt(P_COUNT * Math.PI) * phi;
                    targets[idx] = 4 * Math.sin(phi) * Math.cos(theta);
                    targets[idx+1] = 4 * Math.sin(phi) * Math.sin(theta);
                    targets[idx+2] = 4 * Math.cos(phi);
                } else if(shape === 'TORUS') { // åœ†ç¯
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI * 2;
                    targets[idx] = (4 + 1.5 * Math.cos(v)) * Math.cos(u);
                    targets[idx+1] = (4 + 1.5 * Math.cos(v)) * Math.sin(u);
                    targets[idx+2] = 1.5 * Math.sin(v);
                } else if(shape === 'HEART') { // çˆ±å¿ƒ
                    const t = Math.random() * Math.PI * 2;
                    targets[idx] = 0.3 * (16 * Math.pow(Math.sin(t), 3));
                    targets[idx+1] = 0.3 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    targets[idx+2] = (Math.random()-0.5) * 2;
                } else if(shape === 'TEXT') { // æ–‡å­—
                    const p = textCoords[i % textCoords.length];
                    targets[idx] = p.x * 1.5; targets[idx+1] = p.y * 1.5; targets[idx+2] = (Math.random()-0.5);
                } else if(shape === 'STAR') { // æ˜Ÿå½¢
                    const t = Math.random() * Math.PI * 2;
                    const r = 3 + 2 * Math.sin(5 * t);
                    targets[idx] = r * Math.cos(t); targets[idx+1] = r * Math.sin(t); targets[idx+2] = (Math.random()-0.5);
                }
            }
        }

        // --- MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
        const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
        hands.onResults(res => {
            if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                handData.active = true;
                const lm = res.multiHandLandmarks[0];
                const wrist = lm[0];
                const middle = lm[9];
                
                // æ·±åº¦åé¦ˆè®¡ç®— (æ‰‹æŒåœ¨ç”»é¢ä¸­çš„è·ç¦»)
                const dist = Math.sqrt(Math.pow(lm[0].x - lm[9].x, 2) + Math.pow(lm[0].y - lm[9].y, 2));
                handData.z = THREE.MathUtils.lerp(handData.z, dist * 10, 0.1);

                // åæ ‡è½¬æ¢ (ä¿®å¤é•œåƒ)
                const curX = (0.5 - lm[9].x) * 35;
                const curY = (0.5 - lm[9].y) * 20;
                
                // æŒ¥æ‰‹é€Ÿåº¦è®¡ç®—
                handData.vX = curX - lastHandPos.x;
                handData.vY = curY - lastHandPos.y;
                lastHandPos = { x: curX, y: curY };
                handData.x = curX; handData.y = curY;

                // æ‰‹åŠ¿åˆ¤æ–­é€»è¾‘
                const isFingerUp = (tip, base) => lm[tip].y < lm[base].y;
                const upCount = [8,12,16,20].filter(i => isFingerUp(i, i-2)).length;
                const thumbUp = lm[4].y < lm[3].y && lm[4].x < lm[3].x; // ç²—ç•¥åˆ¤æ–­å¤§æ‹‡æŒ‡

                if(upCount >= 4) { setTargetShape('SPHERE'); panel.innerText = "ğŸ–ï¸ å¼ æ‰‹å˜çƒ"; }
                else if(upCount === 2) { setTargetShape('TEXT'); panel.innerText = "âœŒï¸ å‰ªåˆ€æ‰‹ï¼šæˆ‘æ˜¯ç™½ä¹Ÿ"; }
                else if(upCount === 0) { setTargetShape('TORUS'); panel.innerText = "âœŠ æ¡æ‹³å˜åœ†ç¯"; }
                else if(upCount === 1) { setTargetShape('STAR'); panel.innerText = "â˜ï¸ é£ŸæŒ‡å˜æ˜Ÿ"; }
                else if(thumbUp) { setTargetShape('HEART'); panel.innerText = "ğŸ‘ ç«–å¤§æ‹‡æŒ‡å˜çˆ±å¿ƒ"; }
            } else {
                handData.active = false;
                panel.innerText = "ç­‰å¾…æ‰‹åŠ¿å…¥åœº...";
            }
        });

        const cam = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 640, height: 480
        });
        cam.start();

        // --- ç‰©ç†æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const pos = particles.geometry.attributes.position.array;
            const speed = Math.sqrt(handData.vX**2 + handData.vY**2);

            for(let i=0; i<P_COUNT; i++) {
                let idx = i * 3;
                // 1. åŸºç¡€å¼•åŠ›ï¼šå‘ç›®æ ‡å½¢çŠ¶ç§»åŠ¨
                vels[idx] += (targets[idx] - pos[idx]) * 0.01;
                vels[idx+1] += (targets[idx+1] - pos[idx+1]) * 0.01;
                vels[idx+2] += (targets[idx+2] - pos[idx+2]) * 0.01;

                // 2. æŒ¥æ‰‹é£æš´ï¼šå¿«é€ŸæŒ¥åŠ¨æ—¶ç‰©ç†å¹æ•£æ•ˆæœ
                if(handData.active && speed > 0.5) {
                    const dx = pos[idx] - handData.x;
                    const dy = pos[idx+1] - handData.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if(d < 5) {
                        vels[idx] += handData.vX * 0.5;
                        vels[idx+1] += handData.vY * 0.5;
                    }
                }

                // 3. ç‰©ç†æ‘©æ“¦åŠ› (é˜²æ­¢æ— ä¼‘æ­¢æŠ–åŠ¨)
                vels[idx] *= 0.92; vels[idx+1] *= 0.92; vels[idx+2] *= 0.92;

                // 4. æ›´æ–°åæ ‡å¹¶åº”ç”¨æ·±åº¦ç¼©æ”¾
                pos[idx] += vels[idx];
                pos[idx+1] += vels[idx+1];
                pos[idx+2] += vels[idx+2];
            }

            // æ·±åº¦æ¨æ‹‰ï¼šæ•´ä½“ç¼©æ”¾ç²’å­ç³»ç»Ÿ
            particles.scale.setScalar(0.5 + handData.z);
            particles.position.set(handData.x, handData.y, 0);
            particles.rotation.y += 0.005;
            
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
