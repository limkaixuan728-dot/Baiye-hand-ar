<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç™½ä¹ŸÂ·ç²’å­å®‡å®™ (æ¡Œé¢ä¸æ»‘ç‰ˆ)</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #panel { position: absolute; top: 15px; left: 15px; z-index: 10; color: #0ff; font-family: "Microsoft YaHei", sans-serif; background: rgba(0,20,40,0.8); padding: 12px; border: 1px solid #0ff; border-radius: 8px; pointer-events: none; font-size: 14px; box-shadow: 0 0 10px #0ff; }
        video { display: none; }
    </style>
</head>
<body>
    <div id="panel">åˆå§‹åŒ– AI è§†è§‰æ ¸å¿ƒ...</div>
    <video id="input_video" playsinline autoplay muted></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const panel = document.getElementById('panel');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- æ ¸å¿ƒå‚æ•°è°ƒèŠ‚ (é’ˆå¯¹æ¡Œé¢æ¨¡å¼) ---
        const P_COUNT = 15000; 
        let currentState = 'SPHERE';
        let handData = { x:0, y:0, z:1, vX:0, vY:0, active: false };
        let lastHandPos = { x:0, y:0 };

        // --- ç²’å­ç³»ç»Ÿåˆå§‹åŒ– ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(P_COUNT * 3);
        const targets = new Float32Array(P_COUNT * 3); 
        const vels = new Float32Array(P_COUNT * 3); 
        
        for(let i=0; i<P_COUNT*3; i++) {
            positions[i] = (Math.random()-0.5)*40;
            vels[i] = 0;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.05, transparent: true, blending: THREE.AdditiveBlending });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);
        camera.position.z = 15;

        // --- æ–‡å­—åæ ‡é‡‡æ · (ç¡®ä¿å±…ä¸­) ---
        const textCoords = [];
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 400; canvas.height = 200;
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = 'bold 60px Arial';
        ctx.fillText('æˆ‘æ˜¯ç™½ä¹Ÿ', 200, 100); // å±…ä¸­ç»˜åˆ¶

        const imgData = ctx.getImageData(0,0,400,200).data;
        for(let y=0; y<200; y+=2) {
            for(let x=0; x<400; x+=2) {
                if(imgData[(y*400+x)*4] > 128) {
                    textCoords.push({x:(x-200)/15, y:(100-y)/15});
                }
            }
        }

        // --- å½¢çŠ¶å˜æ¢å¼•æ“ ---
        function setTargetShape(shape) {
            if(currentState === shape) return;
            currentState = shape;
            for(let i=0; i<P_COUNT*3; i++) vels[i] += (Math.random()-0.5) * 3; // åˆ‡æ¢æ—¶çš„çˆ†ç‚¸æ„Ÿ

            for(let i=0; i<P_COUNT; i++) {
                let idx = i * 3;
                if(shape === 'SPHERE') {
                    const phi = Math.acos(-1 + (2 * i) / P_COUNT);
                    const theta = Math.sqrt(P_COUNT * Math.PI) * phi;
                    targets[idx] = 5 * Math.sin(phi) * Math.cos(theta);
                    targets[idx+1] = 5 * Math.sin(phi) * Math.sin(theta);
                    targets[idx+2] = 5 * Math.cos(phi);
                } else if(shape === 'TEXT') {
                    const p = textCoords[i % textCoords.length];
                    targets[idx] = p.x; targets[idx+1] = p.y; targets[idx+2] = (Math.random()-0.5)*2;
                } else if(shape === 'TORUS') {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI * 2;
                    targets[idx] = (5 + 1.5 * Math.cos(v)) * Math.cos(u);
                    targets[idx+1] = (5 + 1.5 * Math.cos(v)) * Math.sin(u);
                    targets[idx+2] = 1.5 * Math.sin(v);
                } else if(shape === 'STAR') {
                    const t = Math.random() * Math.PI * 2;
                    const r = 4 + 2 * Math.sin(5 * t);
                    targets[idx] = r * Math.cos(t); targets[idx+1] = r * Math.sin(t); targets[idx+2] = (Math.random()-0.5);
                } else if(shape === 'HEART') {
                    const t = Math.random() * Math.PI * 2;
                    targets[idx] = 0.4 * (16 * Math.pow(Math.sin(t), 3));
                    targets[idx+1] = 0.4 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    targets[idx+2] = (Math.random()-0.5);
                }
            }
        }

        // --- AI è§†è§‰è¯†åˆ« (é•œåƒ+çµæ•åº¦è°ƒä¼˜) ---
        const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
        
        hands.onResults(res => {
            if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                handData.active = true;
                const lm = res.multiHandLandmarks[0];
                
                // æ·±åº¦åé¦ˆ (æ¡Œé¢ä¼˜åŒ–)
                const dist = Math.sqrt(Math.pow(lm[0].x - lm[9].x, 2) + Math.pow(lm[0].y - lm[9].y, 2));
                handData.z = THREE.MathUtils.lerp(handData.z, dist * 4.5, 0.1);

                // é•œåƒä¿®å¤ & æ¡Œé¢æ¨¡å¼åæ ‡ç¼©æ”¾
                const curX = (0.5 - lm[9].x) * 16; 
                const curY = (0.5 - lm[9].y) * 10;
                
                handData.vX = curX - lastHandPos.x;
                handData.vY = curY - lastHandPos.y;
                lastHandPos = { x: curX, y: curY };
                handData.x = curX; handData.y = curY;

                // æ‰‹åŠ¿çŠ¶æ€åˆ‡æ¢
                const isUp = (tip, base) => lm[tip].y < lm[base].y;
                const upFingers = [8,12,16,20].filter(i => isUp(i, i-2)).length;
                
                if(upFingers >= 4) { setTargetShape('SPHERE'); panel.innerText = "ğŸ–ï¸ å¼ æ‰‹ï¼šç²’å­èƒ½é‡çƒ"; }
                else if(upFingers === 2) { setTargetShape('TEXT'); panel.innerText = "âœŒï¸ å‰ªåˆ€æ‰‹ï¼šå±…ä¸­æ—‹è½¬Â·æˆ‘æ˜¯ç™½ä¹Ÿ"; }
                else if(upFingers === 0) { setTargetShape('TORUS'); panel.innerText = "âœŠ æ¡æ‹³ï¼šé‡å­åœ†ç¯"; }
                else if(upFingers === 1) { setTargetShape('STAR'); panel.innerText = "â˜ï¸ é£ŸæŒ‡ï¼šäº”è§’æ˜Ÿ"; }
                else { setTargetShape('HEART'); panel.innerText = "â¤ï¸ è¯†åˆ«ä¸­..."; }
            } else {
                handData.active = false;
                panel.innerText = "è¯·ä¸¾èµ·æ‰‹æŒå¼€å§‹äº¤äº’";
            }
        });

        const cam = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 640, height: 480
        });
        cam.start();

        // --- ç‰©ç†æ¸²æŸ“å¼•æ“ ---
        function animate() {
            requestAnimationFrame(animate);
            const pos = particles.geometry.attributes.position.array;
            const speed = Math.sqrt(handData.vX**2 + handData.vY**2);

            for(let i=0; i<P_COUNT; i++) {
                let idx = i * 3;
                // å¼•åŠ›ç®—æ³•
                vels[idx] += (targets[idx] - pos[idx]) * 0.02;
                vels[idx+1] += (targets[idx+1] - pos[idx+1]) * 0.02;
                vels[idx+2] += (targets[idx+2] - pos[idx+2]) * 0.02;

                // æŒ¥æ‰‹ç‰©ç†é£æš´
                if(handData.active && speed > 0.4) {
                    const dx = pos[idx] - handData.x;
                    const dy = pos[idx+1] - handData.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if(d < 4) {
                        vels[idx] += handData.vX * 0.4;
                        vels[idx+1] += handData.vY * 0.4;
                    }
                }

                // æ‘©æ“¦åŠ›
                vels[idx] *= 0.9; vels[idx+1] *= 0.9; vels[idx+2] *= 0.9;
                pos[idx] += vels[idx]; pos[idx+1] += vels[idx+1]; pos[idx+2] += vels[idx+2];
            }

            // æ·±åº¦æ¨æ‹‰ä¸å±…ä¸­æ—‹è½¬é€»è¾‘
            particles.scale.setScalar(0.3 + handData.z);
            particles.position.set(handData.x, handData.y, 0);
            particles.rotation.y += 0.015; // æ•´ä½“æ—‹è½¬æ•ˆæœ
            
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
