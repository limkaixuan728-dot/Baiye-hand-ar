<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>白也的粒子宇宙 - 最终版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #info { position: absolute; top: 10px; left: 10px; z-index: 100; color: #0ff; font-family: sans-serif; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px; }
        video { display: none; }
    </style>
</head>
<body>
    <div id="info">状态：等待手势...</div>
    <video id="input_video" playsinline autoplay muted></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const info = document.getElementById('info');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 粒子系统升级 ---
        const count = 15000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const randoms = new Float32Array(count); // 给每个粒子一个独特的性格

        for(let i = 0; i < count; i++) {
            positions[i*3] = (Math.random() - 0.5) * 20;
            positions[i*3+1] = (Math.random() - 0.5) * 20;
            positions[i*3+2] = (Math.random() - 0.5) * 20;
            randoms[i] = Math.random();
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.06, transparent: true, blending: THREE.AdditiveBlending });
        const points = new THREE.Points(geometry, material);
        scene.add(points);
        camera.position.z = 15;

        let handX = 0, handY = 0, handActive = false;

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1 });
        hands.onResults((res) => {
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                handActive = true;
                const lm = res.multiHandLandmarks[0][9];
                // 【修复左右反转】这里从 (0.5 - lm.x) 改成了 (lm.x - 0.5)
                handX = (lm.x - 0.5) * 30; 
                handY = (0.5 - lm.y) * 20;
                info.innerText = "已识别：手掌模式";
            } else {
                handActive = false;
                info.innerText = "等待手势...";
            }
        });

        const cam = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 640, height: 480
        });
        cam.start();

        function animate() {
            requestAnimationFrame(animate);
            const pos = points.geometry.attributes.position.array;
            
            for(let i = 0; i < count; i++) {
                if(handActive) {
                    // 让粒子不再挤成一个点，而是形成一个有半径的球体 (Radius = 2)
                    const angle = randoms[i] * Math.PI * 2;
                    const shift = Math.sin(Date.now() * 0.002 + i) * 1.5;
                    
                    const targetX = handX + Math.cos(angle) * (2 + shift);
                    const targetY = handY + Math.sin(angle) * (2 + shift);
                    
                    pos[i*3] += (targetX - pos[i*3]) * 0.1;
                    pos[i*3+1] += (targetY - pos[i*3+1]) * 0.1;
                    pos[i*3+2] += (0 - pos[i*3+2]) * 0.1;
                } else {
                    // 无手时的怠速旋转
                    pos[i*3] += Math.sin(Date.now() * 0.001 + i) * 0.02;
                    pos[i*3+1] += Math.cos(Date.now() * 0.001 + i) * 0.02;
                }
            }
            points.geometry.attributes.position.needsUpdate = true;
            points.rotation.y += 0.001;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
