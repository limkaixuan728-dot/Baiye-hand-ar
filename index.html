<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç™½ä¹ŸÂ·ç²’å­å®‡å®™ (å›¾æ–‡ç»ˆæç‰ˆ)</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #panel { position: absolute; top: 15px; left: 15px; z-index: 10; color: #0ff; font-family: "Microsoft YaHei", sans-serif; background: rgba(0,20,40,0.8); padding: 12px; border: 1px solid #0ff; border-radius: 8px; pointer-events: none; font-size: 14px; box-shadow: 0 0 10px #0ff; }
        video { display: none; }
    </style>
</head>
<body>
    <div id="panel">åˆå§‹åŒ– AI è§†è§‰æ ¸å¿ƒ...</div>
    <video id="input_video" playsinline autoplay muted></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const panel = document.getElementById('panel');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- æ ¸å¿ƒå‚æ•° ---
        const P_COUNT = 18000; 
        let currentState = 'SPHERE';
        let handData = { x:0, y:0, z:1, vX:0, vY:0, active: false };
        let lastHandPos = { x:0, y:0 };
        const defaultColor = new THREE.Color(0x00ffff);

        // --- ç²’å­ç³»ç»Ÿåˆå§‹åŒ– (æ”¯æŒå˜è‰²) ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(P_COUNT * 3);
        const colors = new Float32Array(P_COUNT * 3); // æ–°å¢ï¼šé¢œè‰²æ•°æ®
        const targets = new Float32Array(P_COUNT * 3); 
        const targetColors = new Float32Array(P_COUNT * 3); // æ–°å¢ï¼šç›®æ ‡é¢œè‰²
        const vels = new Float32Array(P_COUNT * 3); 
        
        for(let i=0; i<P_COUNT; i++) {
            let idx = i*3;
            positions[idx] = (Math.random()-0.5)*50; positions[idx+1] = (Math.random()-0.5)*50; positions[idx+2] = (Math.random()-0.5)*50;
            colors[idx] = defaultColor.r; colors[idx+1] = defaultColor.g; colors[idx+2] = defaultColor.b;
            vels[idx] = vels[idx+1] = vels[idx+2] = 0;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); // å¯ç”¨é¡¶ç‚¹é¢œè‰²

        // ä½¿ç”¨æ”¯æŒé¡¶ç‚¹é¢œè‰²çš„æè´¨
        const material = new THREE.PointsMaterial({ size: 0.06, transparent: true, blending: THREE.AdditiveBlending, vertexColors: true });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);
        camera.position.z = 18;

        // --- é‡‡æ ·æ•°æ®å®¹å™¨ ---
        let textSamples = [], imageSamples = [];

        // --- 1. æ–‡å­—é‡‡æ · ---
        const textCanvas = document.createElement('canvas');
        const textCtx = textCanvas.getContext('2d');
        textCanvas.width = 400; textCanvas.height = 200;
        textCtx.fillStyle = 'white'; textCtx.textAlign = 'center'; textCtx.textBaseline = 'middle';
        textCtx.font = 'bold 70px Arial'; textCtx.fillText('æˆ‘æ˜¯ç™½ä¹Ÿ', 200, 100);
        const textImgData = textCtx.getImageData(0,0,400,200).data;
        for(let y=0; y<200; y+=2) for(let x=0; x<400; x+=2) if(textImgData[(y*400+x)*4]>128) textSamples.push({x:(x-200)/12, y:(100-y)/12});

        // --- 2. å›¾ç‰‡é‡‡æ · (æ ¸å¿ƒæ–°åŠŸèƒ½) ---
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = 'ok.png'; // å¿…é¡»ç¡®ä¿ GitHub ä¸Šæœ‰è¿™ä¸ªæ–‡ä»¶
        img.onload = () => {
            const imgCanvas = document.createElement('canvas');
            const imgCtx = imgCanvas.getContext('2d');
            // å°†å›¾ç‰‡ç¼©æ”¾åˆ°åˆé€‚å¤§å°è¿›è¡Œé‡‡æ ·
            const scale = 300 / Math.max(img.width, img.height);
            imgCanvas.width = img.width * scale; imgCanvas.height = img.height * scale;
            imgCtx.drawImage(img, 0, 0, imgCanvas.width, imgCanvas.height);
            const imgData = imgCtx.getImageData(0,0,imgCanvas.width,imgCanvas.height).data;
            for(let y=0; y<imgCanvas.height; y+=2) {
                for(let x=0; x<imgCanvas.width; x+=2) {
                    const i = (y*imgCanvas.width+x)*4;
                    if(imgData[i+3] > 128) { // å¦‚æœä¸æ˜¯é€æ˜çš„
                        imageSamples.push({
                            x: (x - imgCanvas.width/2)/8, 
                            y: (imgCanvas.height/2 - y)/8,
                            r: imgData[i]/255, g: imgData[i+1]/255, b: imgData[i+2]/255 // è®°å½•é¢œè‰²
                        });
                    }
                }
            }
            console.log("å›¾ç‰‡é‡‡æ ·å®Œæˆï¼Œæ ·æœ¬æ•°:", imageSamples.length);
        };

        // --- å½¢çŠ¶å˜æ¢å¼•æ“ (å«é¢œè‰²) ---
        function setTargetShape(shape) {
            if(currentState === shape) return;
            currentState = shape;
            for(let i=0; i<P_COUNT*3; i++) vels[i] += (Math.random()-0.5) * 3;

            for(let i=0; i<P_COUNT; i++) {
                let idx = i * 3;
                // é»˜è®¤æ¢å¤ä¸ºé’è‰²
                targetColors[idx] = defaultColor.r; targetColors[idx+1] = defaultColor.g; targetColors[idx+2] = defaultColor.b;

                if(shape === 'IMAGE' && imageSamples.length > 0) {
                    const s = imageSamples[i % imageSamples.length];
                    targets[idx] = s.x; targets[idx+1] = s.y; targets[idx+2] = (Math.random()-0.5)*0.5;
                    // è®¾ç½®ä¸ºå›¾ç‰‡é¢œè‰²
                    targetColors[idx] = s.r; targetColors[idx+1] = s.g; targetColors[idx+2] = s.b;
                } else if(shape === 'TEXT') {
                    const s = textSamples[i % textSamples.length];
                    targets[idx] = s.x; targets[idx+1] = s.y; targets[idx+2] = (Math.random()-0.5)*0.5;
                } else if(shape === 'SPHERE') {
                    const phi = Math.acos(-1 + (2 * i) / P_COUNT); const theta = Math.sqrt(P_COUNT * Math.PI) * phi;
                    targets[idx] = 6 * Math.sin(phi) * Math.cos(theta); targets[idx+1] = 6 * Math.sin(phi) * Math.sin(theta); targets[idx+2] = 6 * Math.cos(phi);
                } else if(shape === 'TORUS') {
                    const u = Math.random()*Math.PI*2; const v = Math.random()*Math.PI*2;
                    targets[idx]=(6+1.5*Math.cos(v))*Math.cos(u); targets[idx+1]=(6+1.5*Math.cos(v))*Math.sin(u); targets[idx+2]=1.5*Math.sin(v);
                } else if(shape === 'STAR') {
                    const t = Math.random()*Math.PI*2; const r = 5 + 2.5 * Math.sin(5 * t);
                    targets[idx]=r*Math.cos(t); targets[idx+1]=r*Math.sin(t); targets[idx+2]=(Math.random()-0.5);
                } else if(shape === 'HEART') {
                    const t = Math.random()*Math.PI*2;
                    targets[idx]=0.5*(16*Math.pow(Math.sin(t),3)); targets[idx+1]=0.5*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)); targets[idx+2]=(Math.random()-0.5);
                }
            }
        }

        // --- AI è§†è§‰è¯†åˆ« ---
        const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
        
        hands.onResults(res => {
            if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                handData.active = true;
                const lm = res.multiHandLandmarks[0];
                // æ·±åº¦ä¸ä½ç½®è®¡ç®—
                const dist = Math.sqrt(Math.pow(lm[0].x-lm[9].x,2) + Math.pow(lm[0].y-lm[9].y,2));
                handData.z = THREE.MathUtils.lerp(handData.z, dist * 4.5, 0.1);
                const curX = (0.5-lm[9].x)*18; const curY = (0.5-lm[9].y)*12;
                handData.vX = curX - lastHandPos.x; handData.vY = curY - lastHandPos.y;
                lastHandPos = { x: curX, y: curY }; handData.x = curX; handData.y = curY;

                // æ‰‹åŠ¿åˆ¤æ–­
                const isUp = (tip, base) => lm[tip].y < lm[base].y;
                const upFingers = [8,12,16,20].filter(i => isUp(i, i-2)).length;
                // OKæ‰‹åŠ¿ï¼šå¤§æ‹‡æŒ‡å°–(4)ä¸é£ŸæŒ‡å°–(8)è·ç¦»å¾ˆè¿‘
                const okDist = Math.sqrt(Math.pow(lm[4].x-lm[8].x,2) + Math.pow(lm[4].y-lm[8].y,2));
                const isOK = okDist < 0.05 && isUp(12,10) && isUp(16,14) && isUp(20,18);

                if(isOK) { setTargetShape('IMAGE'); panel.innerText = "ğŸ‘Œ OKæ‰‹åŠ¿ï¼šå¬å”¤å¡é€šå½¢è±¡"; }
                else if(upFingers >= 4) { setTargetShape('SPHERE'); panel.innerText = "ğŸ–ï¸ å¼ æ‰‹ï¼šèƒ½é‡çƒ"; }
                else if(upFingers === 2) { setTargetShape('TEXT'); panel.innerText = "âœŒï¸ å‰ªåˆ€æ‰‹ï¼šæˆ‘æ˜¯ç™½ä¹Ÿ"; }
                else if(upFingers === 0) { setTargetShape('TORUS'); panel.innerText = "âœŠ æ¡æ‹³ï¼šåœ†ç¯"; }
                else if(upFingers === 1) { setTargetShape('STAR'); panel.innerText = "â˜ï¸ é£ŸæŒ‡ï¼šäº”è§’æ˜Ÿ"; }
                else { setTargetShape('HEART'); panel.innerText = "â¤ï¸ çˆ±å¿ƒ (æˆ–è°ƒæ•´æ‰‹åŠ¿)"; }
            } else {
                handData.active = false;
                panel.innerText = "è¯·ä¸¾èµ·æ‰‹æŒ...";
            }
        });

        const cam = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 640, height: 480
        });
        cam.start();

        // --- ç‰©ç†æ¸²æŸ“å¼•æ“ ---
        function animate() {
            requestAnimationFrame(animate);
            const pos = particles.geometry.attributes.position.array;
            const col = particles.geometry.attributes.color.array;
            const speed = Math.sqrt(handData.vX**2 + handData.vY**2);

            for(let i=0; i<P_COUNT; i++) {
                let idx = i * 3;
                // ä½ç½®å¼•åŠ›
                vels[idx] += (targets[idx] - pos[idx]) * 0.03;
                vels[idx+1] += (targets[idx+1] - pos[idx+1]) * 0.03;
                vels[idx+2] += (targets[idx+2] - pos[idx+2]) * 0.03;
                
                // é¢œè‰²æ¸å˜
                col[idx] += (targetColors[idx] - col[idx]) * 0.05;
                col[idx+1] += (targetColors[idx+1] - col[idx+1]) * 0.05;
                col[idx+2] += (targetColors[idx+2] - col[idx+2]) * 0.05;

                // æŒ¥æ‰‹é£æš´
                if(handData.active && speed > 0.4) {
                    const dx = pos[idx]-handData.x; const dy = pos[idx+1]-handData.y;
                    if(Math.sqrt(dx*dx+dy*dy) < 4) { vels[idx]+=handData.vX*0.4; vels[idx+1]+=handData.vY*0.4; }
                }
                // ç‰©ç†åº”ç”¨
                vels[idx]*=0.9; vels[idx+1]*=0.9; vels[idx+2]*=0.9;
                pos[idx]+=vels[idx]; pos[idx+1]+=vels[idx+1]; pos[idx+2]+=vels[idx+2];
            }
            // æ•´ä½“å˜æ¢
            particles.scale.setScalar(0.3 + handData.z);
            particles.position.set(handData.x, handData.y, 0);
            particles.rotation.y += 0.01;
            
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });
    </script>
</body>
</html>
