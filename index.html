<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<title>WebAR Particle Hand System</title>
<style>
html,body{margin:0;overflow:hidden;background:#000}
canvas{display:block}
</style>
</head>
<body>

<video id="video" style="display:none"></video>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
<script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ===================== 基础 Three ===================== */
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,100)
camera.position.z = 4

const renderer = new THREE.WebGLRenderer({antialias:true})
renderer.setSize(innerWidth,innerHeight)
renderer.setPixelRatio(devicePixelRatio)
document.body.appendChild(renderer.domElement)

/* ===================== 粒子系统 ===================== */
const COUNT = 16000
const pos = new Float32Array(COUNT*3)
const vel = new Float32Array(COUNT*3)
const acc = new Float32Array(COUNT*3)

for(let i=0;i<COUNT;i++){
  pos[i*3]=(Math.random()-0.5)*2
  pos[i*3+1]=(Math.random()-0.5)*2
  pos[i*3+2]=(Math.random()-0.5)*2
}

const geo = new THREE.BufferGeometry()
geo.setAttribute('position',new THREE.BufferAttribute(pos,3))
const mat = new THREE.PointsMaterial({
  color:0x00ffff,
  size:0.015,
  transparent:true,
  opacity:0.85
})
const particles = new THREE.Points(geo,mat)
scene.add(particles)

/* ===================== 形态生成 ===================== */
function shapeSphere(){
  for(let i=0;i<COUNT;i++){
    const r = Math.cbrt(Math.random())
    const t = Math.random()*Math.PI*2
    const p = Math.acos(2*Math.random()-1)
    acc[i*3]=Math.sin(p)*Math.cos(t)*r
    acc[i*3+1]=Math.cos(p)*r
    acc[i*3+2]=Math.sin(p)*Math.sin(t)*r
  }
}

function shapeRing(){
  for(let i=0;i<COUNT;i++){
    const a=Math.random()*Math.PI*2
    acc[i*3]=Math.cos(a)
    acc[i*3+1]=(Math.random()-0.5)*0.1
    acc[i*3+2]=Math.sin(a)
  }
}

function shapeStar(){
  for(let i=0;i<COUNT;i++){
    const a=Math.random()*Math.PI*2
    const r=(Math.sin(5*a)>0?1:0.5)
    acc[i*3]=Math.cos(a)*r
    acc[i*3+1]=Math.sin(a)*r
    acc[i*3+2]=(Math.random()-0.5)*0.2
  }
}

function shapeHeart(){
  for(let i=0;i<COUNT;i++){
    const t=Math.random()*Math.PI*2
    const x=16*Math.pow(Math.sin(t),3)/18
    const y=(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))/18
    acc[i*3]=x
    acc[i*3+1]=y
    acc[i*3+2]=(Math.random()-0.5)*0.2
  }
}

function shapeText(){
  const c=document.createElement('canvas')
  c.width=512;c.height=256
  const g=c.getContext('2d')
  g.fillStyle='#000'
  g.fillRect(0,0,512,256)
  g.fillStyle='#0ff'
  g.font='bold 90px sans-serif'
  g.textAlign='center'
  g.textBaseline='middle'
  g.fillText('我是白也',256,128)

  const d=g.getImageData(0,0,512,256).data
  let idx=0
  for(let y=0;y<256;y+=4)
  for(let x=0;x<512;x+=4){
    if(d[(y*512+x)*4+3]>0 && idx<COUNT){
      acc[idx*3]=(x/512-0.5)*2
      acc[idx*3+1]=(0.5-y/256)
      acc[idx*3+2]=0
      idx++
    }
  }
}

/* ===================== 爆炸过渡 ===================== */
function explode(){
  for(let i=0;i<COUNT;i++){
    vel[i*3]+=(Math.random()-0.5)*2
    vel[i*3+1]+=(Math.random()-0.5)*2
    vel[i*3+2]+=(Math.random()-0.5)*2
  }
}

/* ===================== MediaPipe Hands ===================== */
let lastGesture=-1
let lastPalm=0
let lastX=0
let stableGesture = -1
let stableCount = 0
const STABLE_FRAMES = 4   // 连续 4 帧才算真的手势

const hands = new Hands({
  locateFile:f=>`https://unpkg.com/@mediapipe/hands/${f}`
})
hands.setOptions({
  maxNumHands:1,
  modelComplexity:1,
  minDetectionConfidence:0.7,
  minTrackingConfidence:0.7
})

hands.onResults(res => {
  if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0) {
    lastGesture = -1
    stableGesture = -1
    stableCount = 0
    lastX = 0
    return
  }

  const lm = res.multiHandLandmarks[0]

  const palm = Math.abs(lm[0].x - lm[9].x)
  particles.scale.setScalar(
    THREE.MathUtils.lerp(0.8, 1.6, palm * 3)
  )

  const speed = Math.abs(lm[0].x - lastX)
  lastX = lm[0].x
  if (speed > 0.03) {
    for (let i = 0; i < COUNT; i++) {
      vel[i * 3]     += (Math.random() - 0.5) * speed * 5
      vel[i * 3 + 1] += (Math.random() - 0.5) * speed * 5
    }
  }

  const open =
    lm[8].y < lm[6].y &&
    lm[12].y < lm[10].y

  const fist =
    lm[8].y > lm[6].y &&
    lm[12].y > lm[10].y

  const scissor =
    lm[8].y < lm[6].y &&
    lm[12].y < lm[10].y &&
    lm[16].y > lm[14].y

  const index =
    lm[8].y < lm[6].y &&
    lm[12].y > lm[10].y

  const thumb =
    lm[4].y < lm[3].y &&
    lm[8].y > lm[6].y &&
    lm[12].y > lm[10].y &&
    lm[16].y > lm[14].y &&
    lm[20].y > lm[18].y

  let g = -1
  if (thumb) g = 4
  else if (fist) g = 2
  else if (scissor) g = 1
  else if (index) g = 3
  else if (open) g = 0

  // ===== 手势稳定判定 =====
  if (g === stableGesture) {
    stableCount++
  } else {
    stableGesture = g
    stableCount = 1
  }

  if (stableCount === STABLE_FRAMES && g !== lastGesture && g !== -1) {
    explode()
    if (g === 0) shapeSphere()
    if (g === 1) shapeText()
    if (g === 2) shapeRing()
    if (g === 3) shapeStar()
    if (g === 4) shapeHeart()
    lastGesture = g
    stableCount = 0
  }
})

const cam = new Camera(document.getElementById('video'),{
  onFrame:async()=>{await hands.send({image:video})},
  width:640,height:480
})
cam.start()

/* ===================== 物理更新 ===================== */
function animate(){
  requestAnimationFrame(animate)
  for(let i=0;i<COUNT;i++){
    vel[i*3]+=(acc[i*3]-pos[i*3])*0.02
    vel[i*3+1]+=(acc[i*3+1]-pos[i*3+1])*0.02
    vel[i*3+2]+=(acc[i*3+2]-pos[i*3+2])*0.02
    vel[i*3]*=0.92
    vel[i*3+1]*=0.92
    vel[i*3+2]*=0.92
    pos[i*3]+=vel[i*3]*0.016
    pos[i*3+1]+=vel[i*3+1]*0.016
    pos[i*3+2]+=vel[i*3+2]*0.016
  }
  geo.attributes.position.needsUpdate=true
  renderer.render(scene,camera)
}
animate()

window.onresize=()=>{
  camera.aspect=innerWidth/innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(innerWidth,innerHeight)
}
</script>
</body>
</html>
