<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<title>OK → 我是白也（Final Stable）</title>
<style>
html,body{
  margin:0;
  overflow:hidden;
  background:#000;
}
canvas{display:block}
</style>
</head>
<body>

<video id="video" style="display:none"></video>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
<script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ===== Three ===== */
const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100)
camera.position.z = 4

const renderer = new THREE.WebGLRenderer({antialias:true})
renderer.setSize(innerWidth, innerHeight)
renderer.setPixelRatio(devicePixelRatio)
document.body.appendChild(renderer.domElement)

/* ===== 粒子 ===== */
const COUNT = 5000
const pos = new Float32Array(COUNT*3)
const target = new Float32Array(COUNT*3)

for(let i=0;i<COUNT;i++){
  pos[i*3]   = (Math.random()-0.5)*3
  pos[i*3+1] = (Math.random()-0.5)*3
  pos[i*3+2] = 0

  target[i*3]   = pos[i*3]
  target[i*3+1] = pos[i*3+1]
  target[i*3+2] = 0
}

const geo = new THREE.BufferGeometry()
geo.setAttribute('position', new THREE.BufferAttribute(pos,3))
const mat = new THREE.PointsMaterial({
  color:0x00ffff,
  size:0.02
})
const points = new THREE.Points(geo, mat)
scene.add(points)

/* ===== 文字目标（所有粒子都有） ===== */
function shapeText(){
  const c = document.createElement('canvas')
  c.width = 600
  c.height = 300
  const g = c.getContext('2d')

  g.clearRect(0,0,c.width,c.height)
  g.fillStyle = '#fff'
  g.font = 'bold 96px sans-serif'
  g.textAlign = 'center'
  g.textBaseline = 'middle'
  g.fillText('我是白也', c.width/2, c.height/2)

  const img = g.getImageData(0,0,c.width,c.height).data
  const pts = []

  for(let y=0;y<c.height;y+=3){
    for(let x=0;x<c.width;x+=3){
      if(img[(y*c.width+x)*4+3] > 0){
        pts.push({
          x:(x/c.width-0.5)*3,
          y:(0.5-y/c.height)*2
        })
      }
    }
  }

  for(let i=0;i<COUNT;i++){
    const p = pts[i % pts.length]   // ✅ 循环使用，永不缺 target
    target[i*3]   = p.x
    target[i*3+1] = p.y
    target[i*3+2] = 0
  }
}

/* ===== MediaPipe OK ===== */
let okStable = 0
let triggered = false

const hands = new Hands({
  locateFile:f=>`https://unpkg.com/@mediapipe/hands/${f}`
})
hands.setOptions({
  maxNumHands:1,
  minDetectionConfidence:0.7,
  minTrackingConfidence:0.7
})

hands.onResults(res=>{
  if(!res.multiHandLandmarks){
    okStable = 0
    triggered = false
    return
  }

  const lm = res.multiHandLandmarks[0]

  const ok =
    Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y) < 0.05 &&
    lm[12].y > lm[10].y &&
    lm[16].y > lm[14].y &&
    lm[20].y > lm[18].y

  if(ok) okStable++
  else { okStable = 0; triggered = false }

  if(okStable > 8 && !triggered){
    triggered = true
    shapeText()
  }
})

const cam = new Camera(document.getElementById('video'),{
  onFrame: async ()=>{ await hands.send({image:video}) },
  width:640,
  height:480
})
cam.start()

/* ===== 动画（绝对安全） ===== */
function animate(){
  requestAnimationFrame(animate)
  for(let i=0;i<COUNT;i++){
    pos[i*3]   += (target[i*3]   - pos[i*3])   * 0.06
    pos[i*3+1] += (target[i*3+1] - pos[i*3+1]) * 0.06
  }
  geo.attributes.position.needsUpdate = true
  renderer.render(scene, camera)
}
animate()

window.onresize=()=>{
  camera.aspect = innerWidth/innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(innerWidth,innerHeight)
}
</script>
</body>
</html>