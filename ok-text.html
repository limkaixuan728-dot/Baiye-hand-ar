<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<title>OK → 我是白也</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  background:#000;
}
canvas{display:block}
</style>
</head>
<body>

<video id="video" style="display:none"></video>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
<script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ================= Three 基础 ================= */
const scene = new THREE.Scene()

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  100
)
camera.position.z = 4

const renderer = new THREE.WebGLRenderer({ antialias:true })
renderer.setSize(window.innerWidth, window.innerHeight)
renderer.setPixelRatio(window.devicePixelRatio)
document.body.appendChild(renderer.domElement)

/* ================= 粒子 ================= */
const COUNT = 12000
const pos = new Float32Array(COUNT * 3)
const vel = new Float32Array(COUNT * 3)
const acc = new Float32Array(COUNT * 3)

for (let i = 0; i < COUNT; i++) {
  pos[i*3]     = (Math.random() - 0.5) * 2
  pos[i*3 + 1] = (Math.random() - 0.5) * 2
  pos[i*3 + 2] = (Math.random() - 0.5) * 2
}

const geo = new THREE.BufferGeometry()
geo.setAttribute('position', new THREE.BufferAttribute(pos, 3))

const mat = new THREE.PointsMaterial({
  color: 0x00ffff,
  size: 0.018,
  transparent: true,
  opacity: 0.9
})

const particles = new THREE.Points(geo, mat)
scene.add(particles)

// ⚠️ 关键：禁止缩放（彻底解决你之前的问题）
particles.scale.set(1,1,1)

/* ================= 文本形态 ================= */
function shapeText(){
  const c = document.createElement('canvas')
  c.width = 512
  c.height = 256
  const g = c.getContext('2d')

  g.fillStyle = '#000'
  g.fillRect(0,0,512,256)

  g.fillStyle = '#0ff'
  g.font = 'bold 96px sans-serif'
  g.textAlign = 'center'
  g.textBaseline = 'middle'
  g.fillText('我是白也', 256, 128)

  const data = g.getImageData(0,0,512,256).data

  let idx = 0
  for (let y = 0; y < 256; y += 3) {
    for (let x = 0; x < 512; x += 3) {
      if (data[(y*512 + x)*4 + 3] > 0 && idx < COUNT) {
        acc[idx*3]     = (x / 512 - 0.5) * 3
        acc[idx*3 + 1] = (0.5 - y / 256) * 1.5
        acc[idx*3 + 2] = 0
        idx++
      }
    }
  }
}

/* ================= MediaPipe Hands ================= */
let okStableCount = 0
let textShown = false
const STABLE_FRAMES = 6   // OK 连续 6 帧才触发

const hands = new Hands({
  locateFile: f => `https://unpkg.com/@mediapipe/hands/${f}`
})

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
})

hands.onResults(res => {
  if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0) {
    okStableCount = 0
    return
  }

  const lm = res.multiHandLandmarks[0]

  // ===== OK 手势（极稳版）=====
  const thumbIndexClose =
    Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y) < 0.05

  const middleStraight = lm[12].y < lm[10].y
  const ringStraight   = lm[16].y < lm[14].y
  const pinkyStraight  = lm[20].y < lm[18].y

  const isOK =
    thumbIndexClose &&
    middleStraight &&
    ringStraight &&
    pinkyStraight

  if (isOK) {
    okStableCount++
  } else {
    okStableCount = 0
  }

  if (okStableCount >= STABLE_FRAMES && !textShown) {
    shapeText()
    textShown = true
  }
})

const cam = new Camera(
  document.getElementById('video'),
  {
    onFrame: async () => {
      await hands.send({ image: video })
    },
    width: 640,
    height: 480
  }
)
cam.start()

/* ================= 动画 ================= */
function animate(){
  requestAnimationFrame(animate)

  for (let i = 0; i < COUNT; i++) {
    vel[i*3]     += (acc[i*3]     - pos[i*3])     * 0.03
    vel[i*3 + 1] += (acc[i*3 + 1] - pos[i*3 + 1]) * 0.03
    vel[i*3 + 2] += (acc[i*3 + 2] - pos[i*3 + 2]) * 0.03

    vel[i*3]     *= 0.9
    vel[i*3 + 1] *= 0.9
    vel[i*3 + 2] *= 0.9

    pos[i*3]     += vel[i*3]     * 0.016
    pos[i*3 + 1] += vel[i*3 + 1] * 0.016
    pos[i*3 + 2] += vel[i*3 + 2] * 0.016
  }

  geo.attributes.position.needsUpdate = true
  renderer.render(scene, camera)
}
animate()

window.onresize = () => {
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(window.innerWidth, window.innerHeight)
}
</script>
</body>
</html>